{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "800d2f23_4e0c472a",
        "filename": "meson.build",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-06-06T07:13:03Z",
      "side": 1,
      "message": "Should we format this ? Because more files will be added\n``` \nspdmd_src \u003d [\u0027src/spdmd.cpp\u0027,\n             \u0027src/spdmd_app.cpp\u0027,\n             ]\n```",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e19d183d_4d077fa8",
        "filename": "meson.build",
        "patchSetId": 4
      },
      "lineNbr": 38,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-06-06T07:13:03Z",
      "side": 1,
      "message": "As this is a spdm-requester application should we rename to `spdm_requesterd` as it would help responder daemon if there is a use case in future ?",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1156ae5_b7bf19c8",
        "filename": "src/spdmd_app.cpp",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-05-20T07:33:02Z",
      "side": 1,
      "message": "nit: I think these comments in this file can be removed. Since it\u0027s self explanatory.",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0435466_287cf2cf",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-20T21:05:37Z",
      "side": 1,
      "message": "I have no idea why we got boost added here.  I\u0027m not accepting a new daemon in this repository using hand-spun boost::asio implementations.  Please see the sdbusplus::async support.",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "694f9fbd_56ab4a88",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-21T10:45:11Z",
      "side": 1,
      "message": "Boost was integrated to support the ASIO-based implementation. If we plan to replace it with sdbusplus::async, does sdbusplus::async provide support for MCTP socket communication?\n\nIn MCTP-based communication with other devices, we rely on the in-kernel socket mechanism. From user space, we open the socket and perform I/O operations directly over it.",
      "parentUuid": "f0435466_287cf2cf",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc251168_7e2aa397",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-21T10:52:18Z",
      "side": 1,
      "message": "Currently all the DMTF libspdm calls are blocking calls,we can go with sdbusplus asio now, but later when we have the asio implemenation in the libspdm, we need the support from sdbusplus or need to use the boost asio.",
      "parentUuid": "694f9fbd_56ab4a88",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e09d9757_19d885e2",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-21T18:56:35Z",
      "side": 1,
      "message": "\u003e If we plan to replace it with sdbusplus::async, does sdbusplus::async provide support for MCTP socket communication?\n\u003e In MCTP-based communication with other devices, we rely on the in-kernel socket mechanism.\n\n`sdbusplus::async` works fine with file descriptors, which sockets are.  Jagpal was able to get it working with GPIO fairly easily.  We can build whatever we need there.\n\n\u003e Currently all the DMTF libspdm calls are blocking calls,we can go with sdbusplus asio now, but later when we have the asio implemenation in the libspdm, we need the support from sdbusplus or need to use the boost asio.\n\nI can\u0027t parse this.  What does libspdm being blocking have to do with {boost,sdbusplus}::asio vs sdbusplus::async?  To be clear we should use sdbusplus::async and not sdbusplus::asio.  I think you made a typo, but maybe not.\n\nHow are we going to use libspdm if it is blocking?  I would have thought the libspdm was like libpldm where it just helps with message pack/unpack operations.  Looking briefly at it, it looks like they are referencing \"libmctp\" but we aren\u0027t using \"libmctp\" anymore on OpenBMC.\n\nIf libspdm _is_ blocking, what is the plan for even integrating it here?  Are you planning on doing more development?  Are we going to run the libspdm interaction in a separate thread?  There are multiple directions and we should get alignment before we just start dropping code.\n\nCan we get some internal code design words from you rather than just code that I have to guess at where you\u0027re going?  I don\u0027t want to see you writing all kinds of code that is just going to be rejected because you\u0027re not aware of where the community has progressed in the last 3 years.",
      "parentUuid": "bc251168_7e2aa397",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ffe037c1_fecc495c",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-23T08:18:14Z",
      "side": 1,
      "message": "Yes you are correct that I wanted to say the sdbusplus::async, Thanks for pointing it out.\n\n\u003e How are we going to use libspdm if it is blocking? I would have thought the libspdm was like libpldm where it just helps with message pack/unpack operations. Looking briefly at it, it looks like they are referencing \"libmctp\" but we aren\u0027t using \"libmctp\" anymore on OpenBMC.\n\nWe plan to use libspdm as it is for now, even though it\u0027s currently blocking. Since only one device will be sharing attestation data at a time, we’ll collect data from one device first, and then proceed to the next(Basically seralise).\n\nMoving forward, we are considering the following enhancements:\n\nCollect attestation data from each device in a separate thread.\nor\nEnhance libspdm itself to support asynchronous operations.\n\nOn that front(Enhancing libspdm), I’ve started a discussion with Steven Bellock (the maintainer of libspdm) to understand if there are any ongoing efforts or plans to support async operations in the library.\n\nAlso, just to clarify: libspdm is different from libpldm. While libpldm mainly handles message packing/unpacking, libspdm implements the full SPDM protocol stack, including state management and error handling.\n\n\u003e Can we get some internal code design words from you rather than just code that I have to guess at where you\u0027re going? I don\u0027t want to see you writing all kinds of code that is just going to be rejected because you\u0027re not aware of where the community has progressed in the last 3 years.\n\nI can put up the design doc, how I am planning to write the code.Do you want me to write the doc in the same repo?",
      "parentUuid": "e09d9757_19d885e2",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdc9a241_6790914c",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-05-23T11:04:16Z",
      "side": 1,
      "message": "\u003e \u003e How are we going to use libspdm if it is blocking? I would have thought the libspdm was like libpldm where it just helps with message pack/unpack operations. Looking briefly at it, it looks like they are referencing \"libmctp\" but we aren\u0027t using \"libmctp\" anymore on OpenBMC.\n\u003e \n\u003e We plan to use libspdm as it is for now, even though it\u0027s currently blocking. Since only one device will be sharing attestation data at a time, we’ll collect data from one device first, and then proceed to the next(Basically seralise).\n\u003e \n\nCan you explain what is blocking in libspdm ?\n\n\n\u003e Moving forward, we are considering the following enhancements:\n\u003e \n\u003e Collect attestation data from each device in a separate thread.\n\u003e or\n\u003e Enhance libspdm itself to support asynchronous operations.\n\u003e \n\u003e On that front(Enhancing libspdm), I’ve started a discussion with Steven Bellock (the maintainer of libspdm) to understand if there are any ongoing efforts or plans to support async operations in the library.\n\u003e \n\nI regularly attend the DMTF SPDM WG as well as the Code TF calls. I never heard any discussion on this. Was there an open/active issue on this ?",
      "parentUuid": "ffe037c1_fecc495c",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93adabd3_7e1565b4",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-23T11:48:21Z",
      "side": 1,
      "message": "\u003eI regularly attend the DMTF SPDM WG as well as the Code TF calls. I never heard any discussion on this. Was there an open/active issue on this ?\n\nhttps://github.com/DMTF/libspdm/issues/2480\n\nHave you ever tried retrieving attestation data from multiple devices simultaneously?\n\nPlease take a look at the code snippet below. While it\u0027s specifically for the GetVersion command, this blocking behavior is common across all SPDM commands\n\nhttps://github.com/DMTF/libspdm/blob/main/library/spdm_requester_lib/libspdm_req_get_version.c#L40",
      "parentUuid": "cdc9a241_6790914c",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea740d92_fa76f488",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-05-27T06:27:55Z",
      "side": 1,
      "message": "IMO, looking at the issue it appears to be nearly two years old, The working group doesn\u0027t seem opposed to the concept—in fact, they\u0027ve made some initial efforts toward addressing it at https://github.com/DMTF/libspdm/pull/2406. However, progress has stalled, likely due to limited bandwidth or prioritization. Given that libspdm has an active and engaged open community, I would rather recommend that we actively contribute to libspdm by progressively introducing asynchronous support for the relevant commands that we need. And in parallel, we can work on integrating those commands within OpenBMC. \n\nAt this stage, I believe a phased approach would be most effective. We should begin by leveraging `sdbusplus::async` infrastructure for our current needs. In parallel, we can contribute to progressively introducing asynchronous support within libspdm for various commands of interest for attestation one by one. This will allow us to integrate smoothly once we get async support in libspdm without blocking our current development efforts.\n\n@patrick - What\u0027s your opinion on this ?",
      "parentUuid": "93adabd3_7e1565b4",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7889bcf2_87cebf78",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-27T07:54:23Z",
      "side": 1,
      "message": "\u003eWe should begin by leveraging sdbusplus::async infrastructure for our current needs.\n\nI’m unclear on how we’re expected to use libspdm in a non-blocking way without modifying it directly. My specific concern is around how all libspdm calls can be integrated into an asynchronous or concurrent flow.\n\nI had a discussion with Steven yesterday, and he confirmed that there is currently no ongoing effort to make the libspdm API asynchronous. He also mentioned that making the API async would involve a significant amount of work.\n\nAs a potential solution, I propose using a multi-threaded model, where each thread maintains its own spdm_context and independently handles a request. However, I haven’t come across any OpenBMC user-space applications that follow this multithreaded approach with libspdm. I have not protyped this approach, If we all are aligned, I can prototype this.\n\nProposed Options\n\nOption 1: Use libspdm as-is and serialize all SPDM requests\n\nAll requests are processed one at a time.\n\nLimitation: If the system has 10 devices, a user cannot retrieve attestation data from a device while another request is in progress.\n\nOption 2: Use a multi-threaded model\n\nEach request is handled by a dedicated worker thread, each with its own spdm_context.\n\nThis allows concurrent handling of requests, avoiding the bottleneck of serialization.\n\nOption 3: Modify libspdm to support async APIs\n\nRequires changes to the libspdm internals to support asynchronous operation.\n\nThis would provide more flexibility but involves a significant development effort.\n\nQuestion\n\nWhat approach should we proceed with?\n\nI’m leaning towards Option 2 (multithreaded model) as a balanced approach, offering concurrency without requiring deep changes to libspdm.",
      "parentUuid": "ea740d92_fa76f488",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4467c34c_004c6d84",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-27T07:57:19Z",
      "side": 1,
      "message": "We can go with option 1 too now for the simplicity - and start working for option3 later.",
      "parentUuid": "7889bcf2_87cebf78",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a67f59c4_178472b1",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-30T09:51:50Z",
      "side": 1,
      "message": "I think an easier approach is:\n\noption2a: all spdm blocking calls are delegated to a single extra thread and the delegation-completion is signaled via a co_await. \n\nI can help with “how” to do this if needed but it sets everything up in a way that it is mostly a trivial change over to option 3 when ready. The important thing to me is that dbus responses by the daemon are non-blocking so that services like object-mapper can always interrogate the spdm daemon.",
      "parentUuid": "4467c34c_004c6d84",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbeeb177_2f059e58",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-05-30T12:35:59Z",
      "side": 1,
      "message": "Thanks, Patrick for the suggeation, I will reach out if I need help to implement this.\n\nI do have one more question: even with this approach, we’re still effectively handling one request at a time — meaning the coroutine remains blocked until the thread finishes the SPDM blocking call.\n\nI was concerned about the performance impact. Our system has over 25 devices, and we need to retrieve attestation data from each of them approximately once per minute. With a single-threaded delegation model, this could become a bottleneck.\n\nWould you see any issues with creating a dedicated thread per device, so each device can be handled independently? This might help us achieve better concurrency and meet our timing requirements.",
      "parentUuid": "a67f59c4_178472b1",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "866833fa_636c1539",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-30T12:51:38Z",
      "side": 1,
      "message": "\u003e I do have one more question: even with this approach, we’re still effectively handling one request at a time — meaning the coroutine remains blocked until the thread finishes the SPDM blocking call.\n\nThe co-routine that initiated the \"request to do some SPDM stuff\" is blocked, yes, but it is blocked until you do the SPDM work anyhow.\n\n\u003e I was concerned about the performance impact. Our system has over 25 devices, and we need to retrieve attestation data from each of them approximately once per minute.\n\nAre these 25 devices all on different busses?  If not, aren\u0027t you going to block anyhow?\n\n\u003e Would you see any issues with creating a dedicated thread per device, so each device can be handled independently? This might help us achieve better concurrency and meet our timing requirements.\n\nI\u0027d rather see a straight-forward implementation and get measurements first.  Depending on what bus we\u0027re talking about, 25 devices once per minute still shouldn\u0027t be an issue.  A single 400kbps I2C bus can probably still get that done.\n\n(Having a \"requirement\" to re-gather the attestation information every minute off 25 sub-devices seems a bit strange to me though.)\n\nRather than a \"dedicated thread per device\", I think it would be way simpler to have a threadpool (which you could compile-time set to 25 if you needed on your system).  You need a workqueue of sorts anyhow in order to get the co-routine to block, dispatch the work to a SPDM worker, etc.  So, having this queue be acted on by multiple threads probably isn\u0027t a large lift.\n\nAt some point we do have to question how much work this is to do multi-threaded vs just doing the necessary in libspdm to make it async.",
      "parentUuid": "fbeeb177_2f059e58",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57601f0b_000a203a",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-06-04T06:42:43Z",
      "side": 1,
      "message": "\u003eAre these 25 devices all on different busses? If not, aren\u0027t you going to block anyhow?\nNo, It is on the same bus, but in MCTP it is not a blocking implementation, They semd the packet asynchronously to multiple endpoints.\n\n\u003eRather than a \"dedicated thread per device\", I think it would be way simpler to have a threadpool (which you could compile-time set to 25 if you needed on your system). You need a workqueue of sorts anyhow in order to get the co-routine to block, dispatch the work to a SPDM worker, etc. So, having this queue be acted on by multiple threads probably isn\u0027t a large lift.\n\nI am implementing both approaches to do the performance test.\n\nImplementation 1 :\nUses pure coroutine/co_await pattern\nDirect integration with SPDM calls\nNo explicit thread management\nUses std::async with proper coroutine suspension/resumption\n\nImplementation 2 :\nHad threads inside coroutines\nUsed explicit thread management with std::unique_ptr\u003cstd::thread\u003e\nMore complex resource management\n\nI plan to create two prototype commits that will allow us to:\nCompare the performance and behavior of both approaches.\n\nI have tested both implementations on VCA with three devices so far. I now plan to extend the testing to include Certificate and Measurement support, along with a few additional devices.\n\nHowever, I will be pushing both prototype commits so that you can review them and get the feedback early on the issues.",
      "parentUuid": "866833fa_636c1539",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18f4e2cc_4d27aaa0",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-06-04T08:33:52Z",
      "side": 1,
      "message": "Yesterday in the SPDM WG call we discussed on the blocking behavior of the requester calls in libspdm \u0026 what they mentioned was it\u0027s not really complex work, its just matter of splitting the API\u0027s into multiple so that we can get the non-blocking behavior as done in https://github.com/DMTF/libspdm/pull/2406 - all they are saying is if we need that - we can work on it since they don\u0027t have ways to test it. If splitting works for one command, we can do the same pattern for every command that we need \u0026 they are okay with that.",
      "parentUuid": "57601f0b_000a203a",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31d47502_141b92b3",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-06-04T14:40:22Z",
      "side": 1,
      "message": "Manoj, we need to ensure support for all API versions—not just 1.1, but also 1.2 and 1.3.\n\nThis can be taken up as a parallel effort after we complete the approach suggested above.\n\nAlso, was there any discussion around chunking? While VCA is a relatively small task, the bigger challenge seems to be with chunking. Even Steven Bellock confirmed this.",
      "parentUuid": "18f4e2cc_4d27aaa0",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bbdc7d3_1d8ff13e",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1002307
      },
      "writtenOn": "2025-06-06T07:13:03Z",
      "side": 1,
      "message": "Should we specify if this is requester application ?",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6768dc27_f45624d8",
        "filename": "src/spdmd_app.hpp",
        "patchSetId": 4
      },
      "lineNbr": 29,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-05-20T07:33:02Z",
      "side": 1,
      "message": "spdmRooTObjectPath in this commit. D-Bus object is added in ComponentIntegrity commit. I think this path can be removed from this commit.",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0c64392_2e8ed7e0",
        "filename": "subprojects/boost.wrap",
        "patchSetId": 4
      },
      "lineNbr": 2,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-05-20T07:33:02Z",
      "side": 1,
      "message": "Don\u0027t we need specific boot version?. In most of the openbmc app repos we have specific version called out and same is used in openbmc recipe.",
      "revId": "526ee16d252ecdca860c5535e8f1ec92998fca52",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}