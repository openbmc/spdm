{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "12111a13_9fcb7277",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-06-25T12:47:29Z",
      "side": 1,
      "message": "Patrick, Manoj, did you get a chance to look into this commit?",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "83b213ed_e46dd8d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-06-26T08:33:01Z",
      "side": 1,
      "message": "Hey ratan - I skimmed through the prototype..and I am in agreement with direction we are taking. Could not review completely since this is in a relation chain with 10 commits below it that does not pass CI. One thing I see missing is that we could have used sdbusplus:async framework rather than we writing our own wrappers - that probably would have avoided a bunch of code.",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98de4a7f_5c1285b3",
        "filename": "meson.build",
        "patchSetId": 3
      },
      "lineNbr": 18,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-06-26T14:43:58Z",
      "side": 1,
      "message": "This needs to be removed. We can add explicit dependency and also a wrapper for cmake dependency.",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ed866b9_276000c4",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-01T14:43:51Z",
      "side": 1,
      "message": "what does this comment means? Is it suggesting that the get_meas_async should be implemented by another dbus service?",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "085aa0e2_28568b20",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-03T05:18:43Z",
      "side": 1,
      "message": "Hi Abhilash,   ComponentIntegrity::spdmGetSignedMeasurements is a D-bus API which is synchronised D-bus API, so we need to wait till the libspdm completes it\u0027s job and return the measurement data.",
      "parentUuid": "8ed866b9_276000c4",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9b84e41_a8c6ea92",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-04T15:34:21Z",
      "side": 1,
      "message": "I\u0027m trying to understand how to implement an asynchronous D-Bus Method. I read that a D-Bus Method call can be asynchronous if the object is hosted by another service. \n\nI\u0027m confused by the statement: \"If we implement the GetMeasurement D-Bus API as an asynchronous call.\" \n\nWho is responsible for implementing GetMeasurementâ€”this service, or an external service?",
      "parentUuid": "085aa0e2_28568b20",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6327c814_51fb99a2",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-01T10:55:39Z",
      "side": 1,
      "message": "does this block? Then what is the use of running async task?",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bbb7630b_d0313297",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-03T09:10:18Z",
      "side": 1,
      "message": "You are correct, it blocks the current thread here. I don\u0027see any breakthrough until we make the GET signed measurememnts as a asynchronus API.\n\nPatrick, Are you convinced with that? If you are ok we can propose the GET Signed measurment API as asynchrnious one.",
      "parentUuid": "6327c814_51fb99a2",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67d27d53_9c9aafa4",
        "filename": "src/component_integrity_dbus.cpp",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-06-26T14:43:58Z",
      "side": 1,
      "message": "Ran 2 get-meas requests 2 for devices and confirmed it\u0027s running parallel.\n\nlibspdm_send_spdm_request[0] msg SPDM_GET_VERSION(0x84), size (0x4):\n0000: 10 84 00 00\nlibspdm_receive_spdm_response[0] msg SPDM_VERSION(0x4), size (0x8):\n0000: 10 04 00 00 00 01 00 11\nlibspdm_send_spdm_request[0] msg SPDM_GET_CAPABILITIES(0xe1), size (0xc):\n0000: 11 e1 00 00 00 00 00 00 00 00 00 00\nlibspdm_receive_spdm_response[0] msg SPDM_CAPABILITIES(0x61), size (0xc):\n0000: 11 61 00 00 00 1a 00 00 32 00 00 00\nlibspdm_send_spdm_request[0] msg SPDM_NEGOTIATE_ALGORITHMS(0xe3), size (0x20):\n0000: 11 e3 00 00 20 00 01 00 90 01 00 00 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nlibspdm_receive_spdm_response[0] msg SPDM_ALGORITHMS(0x63), size (0x24):\n0000: 11 63 00 00 24 00 01 00 04 00 00 00 80 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0020: 00 00 00 00\nlibspdm_send_spdm_request[0] msg SPDM_GET_DIGESTS(0x81), size (0x4):\n0000: 11 81 00 00\nlibspdm_receive_spdm_response[0] msg SPDM_DIGESTS(0x1), size (0x64):\n0000: 11 01 00 03 02 d4 ca 05 99 41 ed d5 3d 90 af 5f d4 8f a8 c0 b7 42 b2 d6 02 e4 50 33 0b bf 47 1e\n0020: 0b 1e 95 96 e8 65 e1 6a 25 5f f3 43 84 78 99 ec 27 7c 74 18 26 3f 4d 3f d8 1a 69 69 60 89 dd 3b\n0040: 7f 7d 98 c5 bf b9 ff 10 8e 51 33 21 1c 74 e3 65 70 a7 85 b4 74 93 32 08 44 3d 30 9e 0d 24 87 56\n0060: 18 11 e2 be\nprovisioned_slot_mask - 0x03\ndigest (0x0) - 02 d4 ca 05 99 41 ed d5 3d 90 af 5f d4 8f a8 c0 b7 42 b2 d6 02 e4 50 33 0b bf 47 1e 0b 1e 95 96 e8 65 e1 6a 25 5f f3 43 84 78 99 ec 27 7c 74 18\ndigest (0x1) - 26 3f 4d 3f d8 1a 69 69 60 89 dd 3b 7f 7d 98 c5 bf b9 ff 10 8e 51 33 21 1c 74 e3 65 70 a7 85 b4 74 93 32 08 44 3d 30 9e 0d 24 87 56 18 11 e2 be\nlibspdm_get_digest completed, slotMask: 0x3, slots: 2, size: 96\n\u003c6\u003e libspdm_get_digest completed, slotMask: 0x{MASK:X}, slots: 2, size: 96\nlibspdm_send_spdm_request[0] msg SPDM_GET_VERSION(0x84), size (0x4):\n0000: 10 84 00 00\nlibspdm_receive_spdm_response[0] msg SPDM_VERSION(0x4), size (0x8):\n0000: 10 04 00 00 00 01 00 11",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e7b431b_13392da0",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-06-30T17:25:14Z",
      "side": 1,
      "message": "We should not be making our own co-routine class.  There is already a good one in sdbusplus (which we get from stdexec, planned to be part of C++26).",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3931f62f_d5570f26",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-06-26T08:33:01Z",
      "side": 1,
      "message": "@ratan - have you looked at sdbusplus::async framework https://github.com/openbmc/sdbusplus/tree/master/include/sdbusplus/async ? we could have leveraged that instead of writing our own wrappers ?",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3407e4ed_99dbf974",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-06-30T17:25:14Z",
      "side": 1,
      "message": "ðŸ’¯\n\n\nThis probably needs to be re-written as a sender/receiver, as that is what C++26 standard-executors will be using, and what sdbusplus/stdexec already support.",
      "parentUuid": "3931f62f_d5570f26",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e3e0def_c0d53c03",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-01T07:59:45Z",
      "side": 1,
      "message": "@patrick@stwcx.xyz: Do you have some example which I can refer?",
      "parentUuid": "3407e4ed_99dbf974",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4aae671_e3ccca93",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-07-01T16:32:32Z",
      "side": 1,
      "message": "The sdbusplus code has multiple examples of sender/receivers.  You can also watch videos by Eric Niebler, who has given multiple talks on them.",
      "parentUuid": "1e3e0def_c0d53c03",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e22ba40a_2759c69a",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-03T09:17:30Z",
      "side": 1,
      "message": "Hi Patrick,\n\n Thanks for sharing the info, I have the code ready with sender/reciver too but even in that implementation we \n- Can execute the libspdm functions asynchronusly.\n- but we need to wait in the GET signed mesaurement untill they are finished which blocks the current thread.\nSo my proposal would be to first fix the D-bus API\nhttps://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Attestation/MeasurementSet.interface.yaml#L5\n\nor we can implement the blocking behaviour first and then later we can implement the asynchronus implementation.",
      "parentUuid": "b4aae671_e3ccca93",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5a29789_b879a30d",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-07-03T15:31:32Z",
      "side": 1,
      "message": "\u003e but we need to wait in the GET signed mesaurement untill they are finished which blocks the current thread.\n\nCan you elaborate on what you mean by \"blocks the current thread\"?  This might be a misunderstanding.\n\nIf you\u0027re using the async sdbusplus bindings, you can `co_await libspdm_stuff(...)` and the _thread_ isn\u0027t blocked, but the request is not answered until the full co-routine completes.  This allows the daemon to service other dbus requests in the meantime.",
      "parentUuid": "e22ba40a_2759c69a",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51788520_78848dc7",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-04T09:30:34Z",
      "side": 1,
      "message": "https://gerrit.openbmc.org/c/openbmc/spdm/+/81124/3/src/component_integrity_dbus.cpp#90 \nI have two options here from this D-bus function\n\nOption 1: Change D-Bus API to Return sdbusplus::async::task\u003c\u003e\n           Co_await on the function which does the libspdm_stuff\n\n\neg: \nauto spdmGetSignedMeasurements(\n    std::vector\u003csize_t\u003e measurementIndices, \n    std::string nonce,\n    size_t slotId) -\u003e sdbusplus::async::task\u003cstd::tuple\u003csdbusplus::message::object_path, std::string, std::string, std::string, std::string, std::string\u003e\u003e\n{\n    // Validate inputs...\n    \n    // Use co_await with the async function\n    auto result \u003d co_await requester::get_digest_async(m_transport-\u003egetSpdmContext(), slotId, m_path);\n    \n    // Process result and return\n    auto [objPath, certType, pubKeyPem, signedMeas, description] \u003d result;\n    co_return std::make_tuple(sdbusplus::message::object_path(objPath), certType, \n                              pubKeyPem, signedMeas, description, typeVersion());\n}\n\nOption 2: Use task.get() (Blocking Call)\n\nstd::tuple\u003csdbusplus::message::object_path, std::string, std::string,\n           std::string, std::string, std::string\u003e\n    ComponentIntegrity::spdmGetSignedMeasurements(\n        std::vector\u003csize_t\u003e measurementIndices, std::string nonce,\n        size_t slotId)\n{\n    // Validate inputs...\n    \n    // Create async task\n    auto task \u003d [this, slotId]() -\u003e sdbusplus::async::task\u003cstd::tuple\u003cstd::string, std::string, std::string, std::string, std::string\u003e\u003e {\n        co_return co_await requester::get_digest_async(m_transport-\u003egetSpdmContext(), slotId, m_path);\n    }();\n    \n    // Block to get result\n    auto result \u003d task.get(); // This blocks!\n    \n    // Process and return\n    auto [objPath, certType, pubKeyPem, signedMeas, description] \u003d result;\n    return std::make_tuple(sdbusplus::message::object_path(objPath), certType, \n                          pubKeyPem, signedMeas, description, typeVersion());\n}\n\n\nAny other way which I am missing, Even I tried it with sender/reciever way but even in that we need to block it in the main thread until the other thread finishes.\nOption 3:\n\n        auto sender \u003d requester::get_digest_async(m_transport-\u003egetSpdmContext(), eid, m_path) |\n                     sdbusplus::async::execution::then([\u0026promise, this](auto result) {\n                         std::cout \u003c\u003c \"[DEBUG] spdmGetSignedMeasurements: Sender completed, setting promise\" \u003c\u003c std::endl;\n                         promise.set_value(result);\n                         std::cout \u003c\u003c \"[DEBUG] spdmGetSignedMeasurements: Requesting async context stop from within async execution\" \u003c\u003c std::endl;\n                         m_asyncCtx-\u003erequest_stop();\n                     });\n\n   \n        // Spawn the sender in the async context\n        m_asyncCtx-\u003espawn(std::move(sender));\n\n      \n        std::thread asyncThread([this]() {\n           \n            try {\n                m_asyncCtx-\u003erun();  // This will block until request_stop() is called\n                \n            } catch (const std::exception\u0026 e) {\n              \n            }\n        });\n\n      \n        // Non-blocking check approach that doesn\u0027t sleep the main thread\n        auto result \u003d wait_for_future_non_blocking_no_sleep(future, std::chrono::seconds(3));",
      "parentUuid": "b5a29789_b879a30d",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d599b836_e4a51600",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-07-04T18:58:57Z",
      "side": 1,
      "message": "I have no idea what you mean by \"Change D-Bus API to return task\".  You can\u0027t change the YAML to return a task.  A task is a co-routine.  You can\u0027t send a co-routine across processes.\n\n```\nOption 1: Change D-Bus API to Return sdbusplus::async::task\u003c\u003e\nCo_await on the function which does the libspdm_stuff\n\neg:\nauto spdmGetSignedMeasurements(\nstd::vector\u003csize_t\u003e measurementIndices,\nstd::string nonce,\nsize_t slotId) -\u003e sdbusplus::async::task\u003cstd::tuple\u003csdbusplus::message::object_path, std::string, std::string, std::string, std::string, std::string\u003e\u003e\n```\n\nThis is code from the generated bindings in `xyz/openbmc_project/Attestation/MeasurementSet/aserver.hpp`: https://gist.github.com/williamspatrick/4dc6bed5e6370b806b27a9bc00ccdd9c\n\nYou need to implement a method call `auto method_call(spdm_get_signed_measurements_t, ...)` that either returns the `tuple` (sync, blocking) or the `task\u003ctuple\u003e` (async, nonblocking) and the bindings automatically do the right thing.  If that method_call returns a task, the message handling for the method call becomes async.\n\nThe sdbusplus examples have this exact scenario: https://github.com/openbmc/sdbusplus/blob/master/example/calculator-aserver.cpp#L14 .  `multiple` is implemented as a synchronous method, `divide` is implemented as an asynchronous method.",
      "parentUuid": "51788520_78848dc7",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 113,
        "endChar": 18
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "677a1d08_dba695fd",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 190,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-01T10:51:50Z",
      "side": 1,
      "message": "Is spawning a thread to make libspdm asynchronous a good idea? This approach introduces concerns about synchronized access to globals like `ctx`, which can make the code slower and harder to debug. Are you using threads due to limitations in the libspdm API? Does libspdm support non-blocking socket mode? If so, you could leverage that feature to avoid spawning threads.",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f867eecd_90a7340e",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 190,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-03T05:18:43Z",
      "side": 1,
      "message": "\u003eIs spawning a thread to make libspdm asynchronous a good idea?\nCan you propose some other solution, considering the libspdm API is synchronus?",
      "parentUuid": "677a1d08_dba695fd",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "287c6d2a_4aac8726",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 190,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-04T15:26:02Z",
      "side": 1,
      "message": "After reviewing the libspdm code, it appears that it is not currently designed for asynchronous programming. If MCTP and DOE sockets support non-blocking modes, we could potentially leverage this to create an asynchronous SPDM library. Since the workload is mostly I/O bound, a single-threaded (main thread) approach could be used to implement concurrent measurement processes. However, the existing SPDM APIs do not seem to support this model. Specifically, `spdm_device_send_message` would need to be converted into a coroutine function, which would require rewriting it in C++ using either `sdbusplus::context` or `asio::context`.\n\nI\u0027m also uncertain whether using threads, as you have suggested, would result in a cleaner solution. Is `spdm_context` designed to be thread-safe? Can we perform parallel measurement retrievals using a single `spdm_context` instance? Personally, I would prefer the asynchronous approach over a threading-based solution.",
      "parentUuid": "f867eecd_90a7340e",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6190df4_d4326054",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 205,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-06-26T08:33:01Z",
      "side": 1,
      "message": "so , is this where it is ideally supposed to be blocked, but since we are running this in a thread spawned by std::async , now it does not ?",
      "range": {
        "startLine": 204,
        "startChar": 4,
        "endLine": 205,
        "endChar": 62
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb617d0e_e5c14bdd",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 205,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-01T08:01:27Z",
      "side": 1,
      "message": "Yes, Exactly",
      "parentUuid": "e6190df4_d4326054",
      "range": {
        "startLine": 204,
        "startChar": 4,
        "endLine": 205,
        "endChar": 62
      },
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b7759e9_09a2442a",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 224,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-06-25T12:46:53Z",
      "side": 1,
      "message": "Here we are showing that how the measurements will gets pulled up, I just implemented till getting the digest. after the digest it needs to call the get certificate followed by the get measurement.",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea23e8c4_fb11abc5",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 224,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2025-06-26T08:33:01Z",
      "side": 1,
      "message": "the get certificate \u0026 get measurement will be spanned in another thread ? or will it be in this same thread ?",
      "parentUuid": "4b7759e9_09a2442a",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cee37c90_e7c9818a",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 224,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-01T08:01:27Z",
      "side": 1,
      "message": "No, it is in the same thread, the whole get measuremenyt in the same thread.",
      "parentUuid": "ea23e8c4_fb11abc5",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c08c35ed_cd253aa5",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 242,
      "author": {
        "id": 1001516
      },
      "writtenOn": "2025-06-26T14:43:58Z",
      "side": 1,
      "message": "@ratankgupta31@gmail.com We will have to generate this id dynamically right?. Currently it\u0027s hardcoded as an example?",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "619364c5_e57fb46e",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 242,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-01T08:01:27Z",
      "side": 1,
      "message": "Yes",
      "parentUuid": "c08c35ed_cd253aa5",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bca4be94_527bc229",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 1001762
      },
      "writtenOn": "2025-07-01T14:43:51Z",
      "side": 1,
      "message": "what does this code mean? it looks like fire and forget pattern . starting a coroutine but not waiting for it to complete? I am not able to figure out how coroutine is better for this? Why don\u0027t you just start a thread ,dettach from it and check for the global variable to see if work done.",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "304e8dc2_91d6c034",
        "filename": "src/libspdm_async.hpp",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2025-07-03T05:18:43Z",
      "side": 1,
      "message": "Although we are not using this piece of code, But that could have been used in the way I described above if we had the GetMeasurement D-Bus API as an asynchrnous one.",
      "parentUuid": "bca4be94_527bc229",
      "revId": "2bbdedd7f6e685619525c6f8ac101d412884111f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}